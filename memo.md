＜参考＞
React 公式ドキュメント

## コンポーネントのネストについて
https://ja.react.dev/learn/your-first-component

- コンポーネントがほかのコンポーネントをレンダーすることはできるが、 コンポーネントの定義をネストさせてはいけない。
- 代わりに、すべてのコンポーネントをトップレベルで定義する。
- 子コンポーネントが親コンポーネントの情報を必要とする場合は、コンポーネント定義をネストさせるのではなく props を通じて渡す。

```
export default function Gallery() {
  // 🔴 Never define a component inside another component!
  function Profile() {
    // ...
  }
  // ...
}
```

```
export default function Gallery() {
  // ...
}

// ✅ Declare components at the top level
function Profile() {
  // ...
}
```

## レンダーとコミット
https://ja.react.dev/learn/adding-interactivity

```
コンポーネントは、画面上に表示される前に React によってレンダーされる必要があります。このプロセスが踏む段階を理解すると、コードがどのように実行されるのか考える際や、コードの振る舞いを説明する際に役立ちます。

コンポーネントが料理人として厨房に立ち、食材を調理して美味しい料理を作っている様子をイメージしてみてください。このシナリオにおいて React はウェイターです。お客様の注文を伝えて、できた料理をお客様に渡します。この UI の「注文」と「提供」のプロセスは、次の 3 つのステップからなります：

レンダーのトリガ（お客様の注文を厨房に伝える）
コンポーネントのレンダー（厨房で注文の品を料理する）
DOM へのコミット（テーブルに注文の品を提供する）
```

このように記載があるが、以下の3パターンだとどうなるか
1. 出来た料理からテーブルに注文の品を提供し、全て揃わずとも食事をとる
   - レンダーのトリガ -> コンポーネントのレンダー -> 随時DOM へのコミット
2. 出来た料理からテーブルに注文の品を提供し、全て揃ってから食事をとる
   - レンダーのトリガ -> 全てのコンポーネントのレンダー -> DOM へのコミット
3. 注文した料理が全てできてからテーブルに品を提供する
   - レンダーのトリガ -> 全てのコンポーネントのレンダー -> 全てのDOM へのコミット

```
Claude.aiによる回答
素晴らしい質問です。これらのパターンは React の異なるレンダリング戦略を表しています。それぞれのパターンについて、React の実際の動作と、それがユーザー体験にどのような影響を与えるかを説明します。

1. 随時コミット（出来た料理から提供し、全て揃わずとも食事をとる）:

   このパターンは React の Concurrent モードに近いです。React 18 で導入された新機能です。

   - 利点：ユーザーはできた部分から見ることができるので、体感的な速度が向上します。
   - 欠点：部分的に更新された UI が一時的に不整合な状態になる可能性があります。
   - React での実装：`useTransition` や `startTransition` APIを使用することで、優先度の低い更新を後回しにできます。

2. 全てのレンダー後にコミット（出来た料理から提供し、全て揃ってから食事をとる）:

   これは React の通常のレンダリングプロセスに最も近いです。

   - 利点：UI の一貫性が保たれます。全てのコンポーネントが最新の状態で表示されます。
   - 欠点：大規模な更新の場合、ユーザーは更新が完了するまで待つ必要があります。
   - React での実装：これはデフォルトの動作です。state が更新されると、関連するコンポーネントツリー全体が再レンダリングされ、その後 DOM に反映されます。

3. 全て準備完了後にコミット（全ての料理ができてから提供する）:

   これは React の Suspense 機能に近いです。データフェッチングなどの非同期操作を扱う際に使用されます。

   - 利点：完全に準備された状態のみが表示されるため、ユーザーは中間状態を見ることがありません。
   - 欠点：更新に時間がかかる場合、ユーザーは長時間待つ必要があるかもしれません。
   - React での実装：`Suspense` コンポーネントと `lazy` 関数を使用することで、コンポーネントやデータが準備できるまでローディング状態を表示できます。

実際の React アプリケーションでは、これらの戦略を組み合わせて使用することが一般的です。例えば、重要なコンテンツは即座に表示し（パターン1）、それ以外の部分は準備が整ってから表示する（パターン3）といった具合です。

適切な戦略の選択は、アプリケーションの要件、パフォーマンスの目標、そしてユーザー体験の設計に基づいて行われます。React の最新機能を活用することで、これらの戦略をより細かく制御することが可能になっています。

```

Reactは2を基本的にとるらしい。公式ドキュメントで確認する。
以下のように書いてあるので、全てのコンポーネントのレンダー後にDOMへのコミットが行われる。

```
初回レンダー時、React はルート (root) コンポーネントを呼び出す。
次回以降のレンダーでは、state の更新によってレンダーがトリガされた関数コンポーネントを、React が呼び出す。

このプロセスは再帰的に発生します。
更新されたコンポーネントが他のコンポーネントを返す場合、次にそのコンポーネントを React がレンダーし、
そのコンポーネントも何かコンポーネントを返す場合、そのコンポーネントも次にレンダーし、といった具合に続きます。
このプロセスは、ネストされたコンポーネントがなくなり、React が画面に表示されるべき内容を知り尽くすまで続きます。

```


## イベントへの応答
https://ja.react.dev/learn/responding-to-events

### イベントハンドラへ渡す関数について
関数は渡すべきものであり、呼び出すものではない。

```
// これは正しい(渡している)
<button onClick={handleClick}>

// これは誤り(呼び出している)
<button onClick={handleClick()}>
```

### イベントの伝播について
イベントハンドラは、コンポーネントが持っている可能性のあるどの子が由来であってもイベントをキャッチする。
このことをイベントがツリーを “バブリング (bubble)” または “伝播 (propagate)” する、と表現する。
イベントは発生した場所から始まり、ツリーを上に向かって進んでいく。
